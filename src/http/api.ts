import type { Association } from '@/model/association.model'
import type { RoleEnum } from '@/model/enums/role.enum'
import type { Member } from '@/model/member.model'
import type { MemberAssociation } from '@/model/member-association.model'
import {
  clearAuthToken,
  getAuthToken,
  isAuthenticated,
  setAuthToken,
} from '@/utils/auth'
import type { DashboardAlertsResumeDTO } from '@/model/dashboard-alerts-resume-dto.model'

/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * TSCON -  Contabilidade e Assessoria
 * API for management of tscon
 * OpenAPI spec version: 1
 */
export interface UserEntity {
  id?: string
  /** @pattern \S+ */
  username?: string
  email?: string
  password?: string
  name?: string
  createdAt?: string
}

export interface AuthDTO {
  password?: string
  username?: string
}

export type MemberAssociationDTORole = (typeof RoleEnum)[keyof typeof RoleEnum]

export type Create200 = { [key: string]: unknown }

export interface Auth200 {
  access_token: string
  expires_in: number // timestamp em milissegundos
  [key: string]: unknown // mantém para propriedades adicionais
}

export type FindAssociationsByFilterParams = {
  filter?: string
}

export type Create1400 = { [key: string]: unknown }

export type GetAssociation400 = { [key: string]: unknown }

const getAuthHeaders = (options?: RequestInit): HeadersInit => {
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    ...options?.headers,
  }

  if (isAuthenticated()) {
    const token = getAuthToken()
    if (token) {
      ;(headers as Record<string, string>).Authorization = `Bearer ${token}`
    }
  }

  return headers
}
export const getCreateUrl = () => {
  return 'http://localhost:8080/user/'
}

export const create = async (
  userEntity: UserEntity,
  options?: RequestInit
): Promise<Create200> => {
  const res = await fetch(getCreateUrl(), {
    ...options,
    method: 'POST',
    headers: getAuthHeaders(options),
    body: JSON.stringify(userEntity),
  })

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Create200 = body ? JSON.parse(body) : {}

  return data
}

export const getAuthUrl = () => {
  return 'http://localhost:8080/auth/'
}

export const auth = async (
  authDTO: AuthDTO,
  options?: RequestInit
): Promise<Auth200> => {
  const res = await fetch(getAuthUrl(), {
    ...options,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    body: JSON.stringify(authDTO),
  })

  if (!res.ok) {
    const errorData = await res.json().catch(() => ({}))
    if (res.status === 401) {
      throw new Error('Usuário e/ou senha inválidos!')
    }
    throw new Error(
      errorData.message || `Authentication failed! status: ${res.status}`
    )
  }

  const data: Auth200 = await res.json()

  if (!data.access_token) {
    throw new Error('Access token not found in response')
  }

  // Armazena o token e o tempo de expiração
  setAuthToken(data.access_token, data.expires_in)

  return data
}

/**
 * This function is reponsible for listing all availables by filter
 * @summary List of available associations
 */
export const getFindAssociationsByFilterUrl = (
  params?: FindAssociationsByFilterParams
) => {
  const normalizedParams = new URLSearchParams()

  // biome-ignore lint/complexity/noForEach: <explanation>
  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  })

  const stringifiedParams = normalizedParams.toString()

  return stringifiedParams.length > 0
    ? `http://localhost:8080/association/?${stringifiedParams}`
    : 'http://localhost:8080/association/'
}

export const findAssociationsByFilter = async (
  params?: FindAssociationsByFilterParams,
  options?: RequestInit
): Promise<Association[]> => {
  const res = await fetch(getFindAssociationsByFilterUrl(params), {
    ...options,
    method: 'GET',
    headers: getAuthHeaders(options),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Association[] = body ? JSON.parse(body) : {}

  return data
}

/**
 * This function is reponsible for register a association
 * @summary Register a association
 */
export const getCreateAssociationUrl = () => {
  return 'http://localhost:8080/association/'
}

export const createAssociation = async (
  associationDTO: Association,
  options?: RequestInit
): Promise<Association> => {
  const res = await fetch(getCreateAssociationUrl(), {
    ...options,
    method: 'POST',
    headers: getAuthHeaders(options),
    body: JSON.stringify(associationDTO),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Association = body ? JSON.parse(body) : {}

  return data
}

/**
 * This function is responsible for searching information about the association
 * @summary Association Information
 */
export const getGetAssociationUrl = (id: number) => {
  return `http://localhost:8080/association/${id}`
}

export const getAssociation = async (
  id: number,
  options?: RequestInit
): Promise<Association> => {
  const res = await fetch(getGetAssociationUrl(id), {
    ...options,
    method: 'GET',
    headers: getAuthHeaders(options),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Association = body ? JSON.parse(body) : {}

  return data
}

/**
 * This function is reponsible for register a association
 * @summary Register a association
 */
export const getUpdateAssociationUrl = (id: number) => {
  return `http://localhost:8080/association/${id}`
}

export const updateAssociation = async (
  id: number,
  associationDTO: Association,
  options?: RequestInit
): Promise<Association> => {
  const res = await fetch(getUpdateAssociationUrl(id), {
    ...options,
    method: 'PUT',
    headers: getAuthHeaders(options),
    body: JSON.stringify(associationDTO),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Association = body ? JSON.parse(body) : {}

  return data
}

/**
 * This function is responsible for searching information about the association
 * @summary Association Information
 */
export const deleteAssociationUrl = (id: number) => {
  return `http://localhost:8080/association/${id}`
}

export const deleteAssociation = async (
  id: number,
  options?: RequestInit
): Promise<Association> => {
  const res = await fetch(deleteAssociationUrl(id), {
    ...options,
    method: 'DELETE',
    headers: getAuthHeaders(options),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Association = body ? JSON.parse(body) : {}

  return data
}

/**
 * This function is reponsible for get an member by cpf
 * @summary Member Information
 */
export const getMemberByCpfUrl = (cpf?: string) => {
  return `http://localhost:8080/member/?cpf=${cpf}`
}

export const getMemberByCpf = async (
  cpf?: string,
  options?: RequestInit
): Promise<Member> => {
  const res = await fetch(getMemberByCpfUrl(cpf), {
    ...options,
    method: 'GET',
    headers: getAuthHeaders(options),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Member = body ? JSON.parse(body) : {}

  return data
}

/**
 * This function is reponsible for get an member by cpf
 * @summary Member Information
 */
export const getDashboardAlertsResumeUrl = () => {
  return 'http://localhost:8080/dashboard/alerts-resume'
}

export const getDashboardAlertsResume = async (
  options?: RequestInit
): Promise<DashboardAlertsResumeDTO> => {
  const res = await fetch(getDashboardAlertsResumeUrl(), {
    ...options,
    method: 'GET',
    headers: getAuthHeaders(options),
  })

  if (res.status === 401) {
    clearAuthToken()
    throw new Error('Unauthorized - Please login again')
  }

  if (!res.ok) {
    throw new Error(`HTTP error! status: ${res.status}`)
  }

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: DashboardAlertsResumeDTO = body ? JSON.parse(body) : {}

  return data
}
